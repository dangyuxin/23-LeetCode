# 5月6日题解

## [827. 最大人工岛 - 力扣（LeetCode）](https://leetcode.cn/problems/making-a-large-island/submissions/529664499/)

![image-20240506223538894](https://picture-cloud-store.oss-cn-beijing.aliyuncs.com/image-20240506223538894.png)

```c++
class Solution {
public:
    vector<int> p, sz;
    int row, col;
    int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};
    int find(int x){
        if(p[x] != x){
            p[x] = find(p[x]);
        }
        return p[x];
    }
    int get(int x, int y){
        return x * col + y;
    }
    int largestIsland(vector<vector<int>>& grid) {
        row = grid.size(), col = grid[0].size();
        for(int i = 0; i < row * col; i++){
            p.push_back(i);
            sz.push_back(1);
        }
        int res = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j]){
                    int a = get(i, j);
                    for(int k = 0; k < 4; k++){
                        int x = i + dx[k], y = j + dy[k];
                        if(x >= 0 && x < row && y >= 0 && y < col && grid[x][y]){
                            int b = get(x, y);
                            if(find(a) != find(b)){
                                sz[find(a)] += sz[find(b)];
                                p[find(b)] = find(a);
                            }
                        }
                    }
                    res = max(res, sz[find(a)]);
                }
            }
        }
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(!grid[i][j]){
                    map<int, int> hash;
                    for(int k = 0; k < 4; k++){
                        int x = i + dx[k], y = j + dy[k];
                        if(x >= 0 && x < row && y >= 0 && y < col && grid[x][y]){
                            int a = get(x, y);
                            hash[find(a)] = sz[find(a)];
                        }
                    }
                    int s = 1;
                    for(auto [k, v] : hash){
                        s += v;
                    }
                    res = max(res, s);
                }
            }
        }
        return res;
    }
};
```

## [463. 岛屿的周长 - 力扣（LeetCode）](https://leetcode.cn/problems/island-perimeter/submissions/529655054/)

![image-20240506223614461](https://picture-cloud-store.oss-cn-beijing.aliyuncs.com/image-20240506223614461.png)

```c++
class Solution {
public:
    int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};
    int islandPerimeter(vector<vector<int>>& grid) {
        int row = grid.size(), col = grid[0].size();
        int res = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j]){
                    for(int k = 0; k < 4; k++){
                        int a = i + dx[k], b = j + dy[k];
                        if(a < 0 || a == row || b < 0 || b == col || grid[a][b] == 0){
                            res++;
                        }
                    }
                }
            }
        }
        return res;
    }
};
```

## [130. 被围绕的区域 - 力扣（LeetCode）](https://leetcode.cn/problems/surrounded-regions/submissions/529574356/)

![image-20240506223654224](https://picture-cloud-store.oss-cn-beijing.aliyuncs.com/image-20240506223654224.png)

```c++
class Solution {
public:
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    vector<vector<char>> g;
    int row, col;
    void solve(vector<vector<char>>& board) {
        g = board;
        row = board.size(), col = board[0].size();
        for(int i = 0; i < row; i++){
            if(g[i][0] == 'O'){
                dfs(i, 0);
            }
            if(g[i][col - 1] == 'O'){
                dfs(i, col - 1);
            }
        }
        for(int j = 0; j < col; j++){
            if(g[0][j] == 'O'){
                dfs(0, j);
            }
            if(g[row - 1][j] == 'O'){
                dfs(row - 1, j);
            }
        }
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(g[i][j] == '#'){
                    g[i][j] = 'O';
                }else{
                    g[i][j] = 'X';
                }
            }
        }
        board = g;
    }
    void dfs(int x, int y){
            g[x][y] = '#';
            for(int i = 0; i < 4; i++){
                int a = x + dx[i];
                int b = y + dy[i];
                if(a >= 0 && a < row && b >= 0 && b < col && g[a][b] == 'O'){
                    dfs(a, b);
                }
            }
        }
};
```

## [417. 太平洋大西洋水流问题 - 力扣（LeetCode）](https://leetcode.cn/problems/pacific-atlantic-water-flow/submissions/529624034/)

![image-20240506223739373](https://picture-cloud-store.oss-cn-beijing.aliyuncs.com/image-20240506223739373.png)

```c++
class Solution {
public:
    int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};
    int row, col;
    vector<vector<int>> g;
    vector<vector<int>> st;
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        g = heights;
        row = heights.size();
        col = heights[0].size();
        st = vector<vector<int>>(row, vector<int>(col));
        for(int i = 0; i < row; i++){
            dfs(i, 0, 1);
        }
        for(int j = 0; j < col; j++){
            dfs(0, j, 1);
        }
        for(int i = 0; i < row; i++){
            dfs(i, col - 1, 2);
        }
        for(int j = 0; j < col; j++){
            dfs(row - 1, j, 2);
        }
        vector<vector<int>> res;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(st[i][j] == 3){
                    res.push_back({i, j});
                }
            }
        }
        return res;
    }
    void dfs(int x, int y, int t){
        if(st[x][y] & t){
            return;
        }
        st[x][y] |= t;
        for(int i = 0; i < 4; i++){
            int a = x + dx[i], b = y + dy[i];
            if(a >= 0 && a < row && b >= 0 && b < col && g[a][b] >= g[x][y]){
                dfs(a, b, t);
            }
        }
    }
};
```

